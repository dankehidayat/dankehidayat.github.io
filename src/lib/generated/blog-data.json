[
  {
    "slug": "energy-monitoring-calibration-linear-regression",
    "title": "Energy Monitoring System Calibration: Linear Regression Approach for Sensor Accuracy",
    "date": "2025-10-14",
    "excerpt": "Improving DHT11 sensor accuracy through linear regression calibration against HTC-1 reference measurements, achieving 0.8°C MAE in temperature and 1.15% MAE in humidity readings.",
    "author": "Danke Hidayat",
    "tags": [
      "iot",
      "data-science",
      "sensor-calibration",
      "linear-regression",
      "python"
    ],
    "categories": [
      "embedded-systems",
      "data-analysis"
    ],
    "labels": [
      "project",
      "tutorial"
    ],
    "content": "\n# Energy Monitoring System Calibration: Linear Regression Approach\n\n## Introduction\n\nIn my ongoing energy monitoring project, accurate room temperature and humidity measurements are crucial for optimizing HVAC system performance and energy consumption. The low-cost DHT11 sensors used in the system required calibration against a professional-grade HTC-1 reference sensor to ensure reliable data collection.\n\n## The Calibration Challenge\n\nThe DHT11 sensor, while cost-effective, exhibited significant measurement errors compared to the HTC-1 reference:\n\n**Pre-Calibration Performance:**\n\n- Temperature MAE: 3.84°C\n- Humidity MAE: 14.18%\n- Temperature Bias: -3.84°C\n- Maximum Error: 4.8°C (temperature), 18% (humidity)\n\nThese errors were unacceptable for energy optimization algorithms that rely on precise environmental data.\n\n## Data Collection Methodology\n\nData was collected simultaneously from both sensors over a 9-hour period, capturing various environmental conditions:\n\n| Timestamp | DHT11 Temp | DHT11 Humidity | HTC-1 Temp | HTC-1 Humidity |\n| :-------- | :--------: | :------------: | :--------: | :------------: |\n| 13:40:29  |   26.7°C   |     46.8%      |   27.5°C   |      48%       |\n| 13:45:31  |   26.7°C   |     51.8%      |   27.7°C   |      54%       |\n| 16:00:32  |   25.2°C   |     64.8%      |   26.6°C   |      64%       |\n| 16:02:41  |   25.2°C   |     64.8%      |   26.5°C   |      64%       |\n| 16:05:33  |   25.2°C   |     64.8%      |   26.5°C   |      64%       |\n| 16:35:29  |   25.2°C   |     63.8%      |   26.3°C   |      63%       |\n| 16:50:28  |   24.8°C   |     63.8%      |   26.2°C   |      63%       |\n| 18:05:29  |   24.4°C   |     68.8%      |   25.6°C   |      67%       |\n| 18:10:31  |   24.4°C   |     68.8%      |   25.6°C   |      67%       |\n| 18:15:30  |   24.4°C   |     68.8%      |   25.6°C   |      67%       |\n| 18:20:30  |   24.4°C   |     68.8%      |   25.5°C   |      67%       |\n| 18:35:30  |   24.4°C   |     69.8%      |   25.3°C   |      68%       |\n| 20:05:35  |   24.4°C   |     70.8%      |   24.2°C   |      72%       |\n| 20:55:31  |   23.9°C   |     72.8%      |   23.7°C   |      73%       |\n| 21:00:32  |   23.5°C   |     73.8%      |   23.8°C   |      73%       |\n| 21:05:32  |   23.5°C   |     73.8%      |   23.8°C   |      73%       |\n| 21:10:32  |   23.5°C   |     73.8%      |   23.6°C   |      73%       |\n| 21:15:31  |   23.5°C   |     73.8%      |   23.6°C   |      73%       |\n| 21:35:33  |   23.5°C   |     73.8%      |   23.4°C   |      73%       |\n\n## Linear Regression Model\n\n### Mathematical Foundation\n\nThe calibration uses simple linear regression to map raw sensor readings to calibrated values:\n\n$$\ny_{\\text{calibrated}} = \\beta_1 \\cdot x_{\\text{raw}} + \\beta_0\n$$\n\nWhere:\n\n- $y_{\\text{calibrated}}$ is the calibrated measurement\n- $x_{\\text{raw}}$ is the raw sensor reading\n- $\\beta_1$ is the slope coefficient\n- $\\beta_0$ is the intercept constant\n\n### Temperature Calibration Model\n\nFor temperature calibration, the regression yielded:\n\n$$\ny_{\\text{temp}} = 1.343x - 7.689\n$$\n\n**Model Statistics:**\n\n- R² = 0.881\n- Standard Error = 0.495°C\n- F-statistic = 125.95\n\n### Humidity Calibration Model\n\nFor humidity calibration:\n\n$$\ny_{\\text{humidity}} = 0.914x + 5.127\n$$\n\n**Model Statistics:**\n\n- R² = 0.981\n- Standard Error = 0.951%\n- F-statistic = 899.14\n\n## Performance Evaluation\n\n### Post-Calibration Results\n\nThe linear regression calibration significantly improved measurement accuracy:\n\n**Temperature Performance:**\n\n- MAE: **0.80°C** (improved from 3.84°C)\n- R²: 0.939\n- Bias: +0.75°C\n- Maximum Error: 1.40°C\n\n**Humidity Performance:**\n\n- MAE: **1.15%** (improved from 14.18%)\n- R²: 0.991\n- Bias: -0.6%\n- Maximum Error: 2.2%\n\n### Mean Absolute Error (MAE) Calculation\n\nThe MAE is calculated as:\n\n$$\n\\text{MAE} = \\frac{1}{n} \\sum_{i=1}^{n} |y_{\\text{predicted}} - y_{\\text{actual}}|\n$$\n\nWhere $n$ is the number of samples in the validation dataset.\n\n## Implementation Code\n\n```python\nimport numpy as np\nfrom sklearn.linear_model import LinearRegression\nfrom sklearn.metrics import mean_absolute_error, r2_score\n\nclass SensorCalibrator:\n    def __init__(self):\n        self.temp_model = LinearRegression()\n        self.humidity_model = LinearRegression()\n\n        # Calibration coefficients from regression analysis\n        self.temp_coef = 1.343379812\n        self.temp_intercept = -7.688931392\n        self.humidity_coef = 0.914240883\n        self.humidity_intercept = 5.127226491\n\n    def calibrate_temperature(self, raw_temp):\n        \"\"\"Calibrate temperature reading using linear regression\"\"\"\n        return self.temp_coef * raw_temp + self.temp_intercept\n\n    def calibrate_humidity(self, raw_humidity):\n        \"\"\"Calibrate humidity reading using linear regression\"\"\"\n        return self.humidity_coef * raw_humidity + self.humidity_intercept\n\n    def evaluate_calibration(self, raw_readings, reference_readings):\n        \"\"\"Evaluate calibration performance\"\"\"\n        calibrated = [self.calibrate_temperature(temp) for temp in raw_readings]\n\n        mae = mean_absolute_error(reference_readings, calibrated)\n        r2 = r2_score(reference_readings, calibrated)\n\n        return {\n            'mae': mae,\n            'r2': r2,\n            'calibrated_readings': calibrated\n        }\n\n# Usage example\ncalibrator = SensorCalibrator()\n\n# Calibrate a new reading\nraw_temp = 25.0\ncalibrated_temp = calibrator.calibrate_temperature(raw_temp)\nprint(f\"Raw: {raw_temp}°C → Calibrated: {calibrated_temp:.2f}°C\")\n```\n\n## Results Visualization\n\nThe calibration significantly improved measurement accuracy across the entire operating range. The scatter plots show excellent linear correlation between calibrated DHT11 readings and HTC-1 reference values.\n\n### Key Improvements:\n\n1. **Temperature Accuracy**: 79% reduction in MAE\n2. **Humidity Accuracy**: 92% reduction in MAE\n3. **Measurement Consistency**: High R² values indicate reliable predictions\n4. **Energy Optimization**: More accurate data for HVAC control algorithms\n\n## Applications in Energy Monitoring\n\nThe calibrated sensors now provide reliable data for:\n\n1. **HVAC Optimization**: Precise temperature control reduces energy waste\n2. **Occupancy Detection**: Accurate environmental changes indicate room usage\n3. **Energy Consumption Analysis**: Correlate environmental conditions with energy usage\n4. **Predictive Maintenance**: Detect abnormal temperature/humidity patterns\n\n## Conclusion\n\nLinear regression provides an effective method for calibrating low-cost environmental sensors. The approach:\n\n- Reduced temperature MAE from 3.84°C to 0.80°C\n- Reduced humidity MAE from 14.18% to 1.15%\n- Maintained computational efficiency for embedded systems\n- Provided mathematically sound calibration with interpretable coefficients\n\nThis calibration enables cost-effective deployment of environmental monitoring systems while maintaining measurement accuracy suitable for energy optimization applications.\n\n**Future Work**: Exploring non-linear calibration models and automated recalibration procedures to account for sensor aging and environmental changes.\n\n---\n\n_Data collected: October 4, 2025 | Analysis completed: October 14, 2025_\n",
    "contentHtml": "<h1>Energy Monitoring System Calibration: Linear Regression Approach</h1><br/>\n<h2>Introduction</h2>\n<p>\nIn my ongoing energy monitoring project, accurate room temperature and humidity measurements are crucial for optimizing HVAC system performance and energy consumption. The low-cost DHT11 sensors used in the system required calibration against a professional-grade HTC-1 reference sensor to ensure reliable data collection.</p><br/>\n<h2>The Calibration Challenge</h2>\n<p>\nThe DHT11 sensor, while cost-effective, exhibited significant measurement errors compared to the HTC-1 reference:</p>\n<p>\n<strong>Pre-Calibration Performance:</strong></p>\n<p>\n<ul><li>Temperature MAE: 3.84°C</p></li>\n<p>- Humidity MAE: 14.18%</p>\n<p>- Temperature Bias: -3.84°C</p>\n<p>- Maximum Error: 4.8°C (temperature), 18% (humidity)</p>\n<p>\nThese errors were unacceptable for energy optimization algorithms that rely on precise environmental data.</p><br/>\n<h2>Data Collection Methodology</h2>\n<p>\nData was collected simultaneously from both sensors over a 9-hour period, capturing various environmental conditions:</p>\n<p>\n| Timestamp | DHT11 Temp | DHT11 Humidity | HTC-1 Temp | HTC-1 Humidity |</p>\n<p>| :-------- | :--------: | :------------: | :--------: | :------------: |</p>\n<p>| 13:40:29  |   26.7°C   |     46.8%      |   27.5°C   |      48%       |</p>\n<p>| 13:45:31  |   26.7°C   |     51.8%      |   27.7°C   |      54%       |</p>\n<p>| 16:00:32  |   25.2°C   |     64.8%      |   26.6°C   |      64%       |</p>\n<p>| 16:02:41  |   25.2°C   |     64.8%      |   26.5°C   |      64%       |</p>\n<p>| 16:05:33  |   25.2°C   |     64.8%      |   26.5°C   |      64%       |</p>\n<p>| 16:35:29  |   25.2°C   |     63.8%      |   26.3°C   |      63%       |</p>\n<p>| 16:50:28  |   24.8°C   |     63.8%      |   26.2°C   |      63%       |</p>\n<p>| 18:05:29  |   24.4°C   |     68.8%      |   25.6°C   |      67%       |</p>\n<p>| 18:10:31  |   24.4°C   |     68.8%      |   25.6°C   |      67%       |</p>\n<p>| 18:15:30  |   24.4°C   |     68.8%      |   25.6°C   |      67%       |</p>\n<p>| 18:20:30  |   24.4°C   |     68.8%      |   25.5°C   |      67%       |</p>\n<p>| 18:35:30  |   24.4°C   |     69.8%      |   25.3°C   |      68%       |</p>\n<p>| 20:05:35  |   24.4°C   |     70.8%      |   24.2°C   |      72%       |</p>\n<p>| 20:55:31  |   23.9°C   |     72.8%      |   23.7°C   |      73%       |</p>\n<p>| 21:00:32  |   23.5°C   |     73.8%      |   23.8°C   |      73%       |</p>\n<p>| 21:05:32  |   23.5°C   |     73.8%      |   23.8°C   |      73%       |</p>\n<p>| 21:10:32  |   23.5°C   |     73.8%      |   23.6°C   |      73%       |</p>\n<p>| 21:15:31  |   23.5°C   |     73.8%      |   23.6°C   |      73%       |</p>\n<p>| 21:35:33  |   23.5°C   |     73.8%      |   23.4°C   |      73%       |</p><br/>\n<h2>Linear Regression Model</h2><br/>\n<h3>Mathematical Foundation</h3>\n<p>\nThe calibration uses simple linear regression to map raw sensor readings to calibrated values:</p>\n<p>\n$$</p>\n<p>y_{\\text{calibrated}} = \\beta_1 \\cdot x_{\\text{raw}} + \\beta_0</p>\n<p>$$</p>\n<p>\nWhere:</p>\n<p>\n<li>$y_{\\text{calibrated}}$ is the calibrated measurement</p></li>\n<p>- $x_{\\text{raw}}$ is the raw sensor reading</p>\n<p>- $\\beta_1$ is the slope coefficient</p>\n<p>- $\\beta_0$ is the intercept constant</p><br/>\n<h3>Temperature Calibration Model</h3>\n<p>\nFor temperature calibration, the regression yielded:</p>\n<p>\n$$</p>\n<p>y_{\\text{temp}} = 1.343x - 7.689</p>\n<p>$$</p>\n<p>\n<strong>Model Statistics:</strong></p>\n<p>\n<li>R² = 0.881</p></li>\n<p>- Standard Error = 0.495°C</p>\n<p>- F-statistic = 125.95</p><br/>\n<h3>Humidity Calibration Model</h3>\n<p>\nFor humidity calibration:</p>\n<p>\n$$</p>\n<p>y_{\\text{humidity}} = 0.914x + 5.127</p>\n<p>$$</p>\n<p>\n<strong>Model Statistics:</strong></p>\n<p>\n<li>R² = 0.981</p></li>\n<p>- Standard Error = 0.951%</p>\n<p>- F-statistic = 899.14</p><br/>\n<h2>Performance Evaluation</h2><br/>\n<h3>Post-Calibration Results</h3>\n<p>\nThe linear regression calibration significantly improved measurement accuracy:</p>\n<p>\n<strong>Temperature Performance:</strong></p>\n<p>\n<li>MAE: <strong>0.80°C</strong> (improved from 3.84°C)</p></li>\n<p>- R²: 0.939</p>\n<p>- Bias: +0.75°C</p>\n<p>- Maximum Error: 1.40°C</p>\n<p>\n<strong>Humidity Performance:</strong></p>\n<p>\n<li>MAE: <strong>1.15%</strong> (improved from 14.18%)</p></li>\n<p>- R²: 0.991</p>\n<p>- Bias: -0.6%</p>\n<p>- Maximum Error: 2.2%</p><br/>\n<h3>Mean Absolute Error (MAE) Calculation</h3>\n<p>\nThe MAE is calculated as:</p>\n<p>\n$$</p>\n<p>\\text{MAE} = \\frac{1}{n} \\sum_{i=1}^{n} |y_{\\text{predicted}} - y_{\\text{actual}}|</p>\n<p>$$</p>\n<p>\nWhere $n$ is the number of samples in the validation dataset.</p><br/>\n<h2>Implementation Code</h2>\n<p>\n<pre><code>python</p>\n<p>import numpy as np</p>\n<p>from sklearn.linear_model import LinearRegression</p>\n<p>from sklearn.metrics import mean_absolute_error, r2_score</p>\n<p>\nclass SensorCalibrator:</p>\n<p>    def __init__(self):</p>\n<p>        self.temp_model = LinearRegression()</p>\n<p>        self.humidity_model = LinearRegression()</p>\n<p>\n        # Calibration coefficients from regression analysis</p>\n<p>        self.temp_coef = 1.343379812</p>\n<p>        self.temp_intercept = -7.688931392</p>\n<p>        self.humidity_coef = 0.914240883</p>\n<p>        self.humidity_intercept = 5.127226491</p>\n<p>\n    def calibrate_temperature(self, raw_temp):</p>\n<p>        \"\"\"Calibrate temperature reading using linear regression\"\"\"</p>\n<p>        return self.temp_coef * raw_temp + self.temp_intercept</p>\n<p>\n    def calibrate_humidity(self, raw_humidity):</p>\n<p>        \"\"\"Calibrate humidity reading using linear regression\"\"\"</p>\n<p>        return self.humidity_coef * raw_humidity + self.humidity_intercept</p>\n<p>\n    def evaluate_calibration(self, raw_readings, reference_readings):</p>\n<p>        \"\"\"Evaluate calibration performance\"\"\"</p>\n<p>        calibrated = [self.calibrate_temperature(temp) for temp in raw_readings]</p>\n<p>\n        mae = mean_absolute_error(reference_readings, calibrated)</p>\n<p>        r2 = r2_score(reference_readings, calibrated)</p>\n<p>\n        return {</p>\n<p>            'mae': mae,</p>\n<p>            'r2': r2,</p>\n<p>            'calibrated_readings': calibrated</p>\n<p>        }</p><br/>\n<h1>Usage example</h1>\n<p>calibrator = SensorCalibrator()</p><br/>\n<h1>Calibrate a new reading</h1>\n<p>raw_temp = 25.0</p>\n<p>calibrated_temp = calibrator.calibrate_temperature(raw_temp)</p>\n<p>print(f\"Raw: {raw_temp}°C → Calibrated: {calibrated_temp:.2f}°C\")</p>\n<p></code></pre></p><br/>\n<h2>Results Visualization</h2>\n<p>\nThe calibration significantly improved measurement accuracy across the entire operating range. The scatter plots show excellent linear correlation between calibrated DHT11 readings and HTC-1 reference values.</p><br/>\n<h3>Key Improvements:</h3>\n<p>\n1. <strong>Temperature Accuracy</strong>: 79% reduction in MAE</p>\n<p>2. <strong>Humidity Accuracy</strong>: 92% reduction in MAE</p>\n<p>3. <strong>Measurement Consistency</strong>: High R² values indicate reliable predictions</p>\n<p>4. <strong>Energy Optimization</strong>: More accurate data for HVAC control algorithms</p><br/>\n<h2>Applications in Energy Monitoring</h2>\n<p>\nThe calibrated sensors now provide reliable data for:</p>\n<p>\n1. <strong>HVAC Optimization</strong>: Precise temperature control reduces energy waste</p>\n<p>2. <strong>Occupancy Detection</strong>: Accurate environmental changes indicate room usage</p>\n<p>3. <strong>Energy Consumption Analysis</strong>: Correlate environmental conditions with energy usage</p>\n<p>4. <strong>Predictive Maintenance</strong>: Detect abnormal temperature/humidity patterns</p><br/>\n<h2>Conclusion</h2>\n<p>\nLinear regression provides an effective method for calibrating low-cost environmental sensors. The approach:</p>\n<p>\n<li>Reduced temperature MAE from 3.84°C to 0.80°C</p></li></ul>\n<p>- Reduced humidity MAE from 14.18% to 1.15%</p>\n<p>- Maintained computational efficiency for embedded systems</p>\n<p>- Provided mathematically sound calibration with interpretable coefficients</p>\n<p>\nThis calibration enables cost-effective deployment of environmental monitoring systems while maintaining measurement accuracy suitable for energy optimization applications.</p>\n<p>\n<strong>Future Work</strong>: Exploring non-linear calibration models and automated recalibration procedures to account for sensor aging and environmental changes.</p>\n<p>\n---</p>\n<p>\n_Data collected: October 4, 2025 | Analysis completed: October 14, 2025_</p>"
  },
  {
    "slug": "category-label",
    "title": "Test page",
    "date": "2025-07-15T00:00:00.000Z",
    "excerpt": "A brief description of the blog post",
    "author": "Danke Hidayat",
    "tags": [
      "React",
      "Next.js",
      "TypeScript",
      "Tailwind CSS"
    ],
    "categories": [
      "Web Development",
      "Tutorial"
    ],
    "labels": [],
    "content": "\n# We are testing categories and label system\n\nlorem ipsum\n",
    "contentHtml": "<h1>We are testing categories and label system</h1>\n<p>\nlorem ipsum</p>"
  },
  {
    "slug": "statistical-mechanics",
    "title": "Statistical Mechanics and Probability",
    "date": "2024-03-15T00:00:00.000Z",
    "excerpt": "Connecting microscopic physics to macroscopic observations through statistics.",
    "author": "Danke Hidayat",
    "tags": [
      "Statistical Mechanics",
      "Thermodynamics",
      "Probability"
    ],
    "categories": [
      "Physics",
      "Mathematics"
    ],
    "labels": [
      "Advanced Physics",
      "Mathematical Modeling"
    ],
    "content": "\n# Statistical Mechanics and Probability\n\n## Boltzmann Distribution\n\n$$\nP_i = \\frac{e^{-E_i/kT}}{Z}\n$$\n\nWhere partition function:\n\n$$\nZ = \\sum_i e^{-E_i/kT}\n$$\n\n## Entropy\n\n$$\nS = -k \\sum_i P_i \\ln P_i\n$$\n\n## Ideal Gas Law\n\nFrom microscopic perspective:\n\n$$\nPV = NkT\n$$\n",
    "contentHtml": "<h1>Statistical Mechanics and Probability</h1><br/>\n<h2>Boltzmann Distribution</h2>\n<p>\n$$</p>\n<p>P_i = \\frac{e^{-E_i/kT}}{Z}</p>\n<p>$$</p>\n<p>\nWhere partition function:</p>\n<p>\n$$</p>\n<p>Z = \\sum_i e^{-E_i/kT}</p>\n<p>$$</p><br/>\n<h2>Entropy</h2>\n<p>\n$$</p>\n<p>S = -k \\sum_i P_i \\ln P_i</p>\n<p>$$</p><br/>\n<h2>Ideal Gas Law</h2>\n<p>\nFrom microscopic perspective:</p>\n<p>\n$$</p>\n<p>PV = NkT</p>\n<p>$$</p>"
  },
  {
    "slug": "number-theory",
    "title": "Number Theory in Cryptography",
    "date": "2024-03-08T00:00:00.000Z",
    "excerpt": "How prime numbers and modular arithmetic secure our digital communications.",
    "author": "Danke Hidayat",
    "tags": [
      "Number Theory",
      "Prime Numbers",
      "RSA",
      "Modular Arithmetic"
    ],
    "categories": [
      "Mathematics",
      "Cryptography"
    ],
    "labels": [
      "Security",
      "Mathematical Foundation"
    ],
    "content": "\n# Number Theory in Cryptography\n\n## RSA Encryption\n\nPublic key: $(n, e)$ where $n = pq$\n\nPrivate key: $d$ where $ed \\equiv 1 \\pmod{\\phi(n)}$\n\nEncryption: $c = m^e \\mod n$\n\nDecryption: $m = c^d \\mod n$\n\n## Euler's Theorem\n\nIf $\\gcd(a,n) = 1$, then:\n\n$$\na^{\\phi(n)} \\equiv 1 \\pmod{n}\n$$\n",
    "contentHtml": "<h1>Number Theory in Cryptography</h1><br/>\n<h2>RSA Encryption</h2>\n<p>\nPublic key: $(n, e)$ where $n = pq$</p>\n<p>\nPrivate key: $d$ where $ed \\equiv 1 \\pmod{\\phi(n)}$</p>\n<p>\nEncryption: $c = m^e \\mod n$</p>\n<p>\nDecryption: $m = c^d \\mod n$</p><br/>\n<h2>Euler's Theorem</h2>\n<p>\nIf $\\gcd(a,n) = 1$, then:</p>\n<p>\n$$</p>\n<p>a^{\\phi(n)} \\equiv 1 \\pmod{n}</p>\n<p>$$</p>"
  },
  {
    "slug": "information-theory",
    "title": "Information Theory and Entropy",
    "date": "2024-03-01T00:00:00.000Z",
    "excerpt": "Quantifying information and uncertainty in communication systems.",
    "author": "Danke Hidayat",
    "tags": [
      "Information Theory",
      "Entropy",
      "Data Compression"
    ],
    "categories": [
      "Mathematics",
      "Computer Science"
    ],
    "labels": [
      "Theoretical Foundation",
      "Practical Applications"
    ],
    "content": "\n# Information Theory and Entropy\n\n## Shannon Entropy\n\n$$\nH(X) = -\\sum_{i=1}^{n} P(x_i) \\log_2 P(x_i)\n$$\n\n## Mutual Information\n\n$$\nI(X;Y) = \\sum_{x,y} P(x,y) \\log \\frac{P(x,y)}{P(x)P(y)}\n$$\n",
    "contentHtml": "<h1>Information Theory and Entropy</h1><br/>\n<h2>Shannon Entropy</h2>\n<p>\n$$</p>\n<p>H(X) = -\\sum_{i=1}^{n} P(x_i) \\log_2 P(x_i)</p>\n<p>$$</p><br/>\n<h2>Mutual Information</h2>\n<p>\n$$</p>\n<p>I(X;Y) = \\sum_{x,y} P(x,y) \\log \\frac{P(x,y)}{P(x)P(y)}</p>\n<p>$$</p>"
  },
  {
    "slug": "differential-equations",
    "title": "Solving Differential Equations",
    "date": "2024-02-22T00:00:00.000Z",
    "excerpt": "Mathematical techniques for modeling continuous change in physical systems.",
    "author": "Danke Hidayat",
    "tags": [
      "Differential Equations",
      "Calculus",
      "Modeling"
    ],
    "categories": [
      "Mathematics",
      "Physics"
    ],
    "labels": [
      "Advanced Mathematics",
      "Physics Applications"
    ],
    "content": "\n# Solving Differential Equations\n\n## Simple Harmonic Motion\n\n$$\n\\frac{d^2x}{dt^2} + \\omega^2 x = 0\n$$\n\nSolution:\n\n$$\nx(t) = A\\cos(\\omega t) + B\\sin(\\omega t)\n$$\n\n## Heat Equation\n\n$$\n\\frac{\\partial u}{\\partial t} = \\alpha \\frac{\\partial^2 u}{\\partial x^2}\n$$\n",
    "contentHtml": "<h1>Solving Differential Equations</h1><br/>\n<h2>Simple Harmonic Motion</h2>\n<p>\n$$</p>\n<p>\\frac{d^2x}{dt^2} + \\omega^2 x = 0</p>\n<p>$$</p>\n<p>\nSolution:</p>\n<p>\n$$</p>\n<p>x(t) = A\\cos(\\omega t) + B\\sin(\\omega t)</p>\n<p>$$</p><br/>\n<h2>Heat Equation</h2>\n<p>\n$$</p>\n<p>\\frac{\\partial u}{\\partial t} = \\alpha \\frac{\\partial^2 u}{\\partial x^2}</p>\n<p>$$</p>"
  },
  {
    "slug": "fourier-analysis",
    "title": "Fourier Analysis and Signal Processing",
    "date": "2024-02-08T00:00:00.000Z",
    "excerpt": "Decomposing signals into frequency components using Fourier transforms.",
    "author": "Danke Hidayat",
    "tags": [
      "Fourier Transform",
      "Frequency Analysis",
      "Digital Signal Processing"
    ],
    "categories": [
      "Mathematics",
      "Signal Processing"
    ],
    "labels": [
      "Advanced Mathematics",
      "Practical Applications"
    ],
    "content": "\n# Fourier Analysis and Signal Processing\n\n## Fourier Transform\n\n$$\nF(\\omega) = \\int_{-\\infty}^{\\infty} f(t) e^{-i\\omega t} dt\n$$\n\n## Inverse Fourier Transform\n\n$$\nf(t) = \\frac{1}{2\\pi} \\int_{-\\infty}^{\\infty} F(\\omega) e^{i\\omega t} d\\omega\n$$\n",
    "contentHtml": "<h1>Fourier Analysis and Signal Processing</h1><br/>\n<h2>Fourier Transform</h2>\n<p>\n$$</p>\n<p>F(\\omega) = \\int_{-\\infty}^{\\infty} f(t) e^{-i\\omega t} dt</p>\n<p>$$</p><br/>\n<h2>Inverse Fourier Transform</h2>\n<p>\n$$</p>\n<p>f(t) = \\frac{1}{2\\pi} \\int_{-\\infty}^{\\infty} F(\\omega) e^{i\\omega t} d\\omega</p>\n<p>$$</p>"
  },
  {
    "slug": "probability-theory",
    "title": "Probability Theory Fundamentals",
    "date": "2024-02-01T00:00:00.000Z",
    "excerpt": "Understanding randomness and uncertainty through mathematical principles.",
    "author": "Danke Hidayat",
    "tags": [
      "Probability",
      "Random Variables",
      "Distributions"
    ],
    "categories": [
      "Mathematics",
      "Statistics"
    ],
    "labels": [
      "Fundamental Concepts",
      "Mathematical Foundation"
    ],
    "content": "\n# Probability Theory Fundamentals\n\n## Bayes' Theorem\n\n$$\nP(A|B) = \\frac{P(B|A)P(A)}{P(B)}\n$$\n\n## Normal Distribution\n\n$$\nf(x) = \\frac{1}{\\sigma\\sqrt{2\\pi}} e^{-\\frac{(x-\\mu)^2}{2\\sigma^2}}\n$$\n",
    "contentHtml": "<h1>Probability Theory Fundamentals</h1><br/>\n<h2>Bayes' Theorem</h2>\n<p>\n$$</p>\n<p>P(A|B) = \\frac{P(B|A)P(A)}{P(B)}</p>\n<p>$$</p><br/>\n<h2>Normal Distribution</h2>\n<p>\n$$</p>\n<p>f(x) = \\frac{1}{\\sigma\\sqrt{2\\pi}} e^{-\\frac{(x-\\mu)^2}{2\\sigma^2}}</p>\n<p>$$</p>"
  },
  {
    "slug": "calculus-optimization",
    "title": "Optimization with Calculus",
    "date": "2024-01-25T00:00:00.000Z",
    "excerpt": "How derivatives and gradients help us find optimal solutions.",
    "author": "Danke Hidayat",
    "tags": [
      "Calculus",
      "Gradient Descent",
      "Derivatives"
    ],
    "categories": [
      "Mathematics",
      "Optimization"
    ],
    "labels": [
      "Mathematical Foundation",
      "Practical Applications"
    ],
    "content": "\n# Optimization with Calculus\n\n## Gradient Descent\n\nThe update rule:\n\n$$\n\\theta_{t+1} = \\theta_t - \\eta \\nabla J(\\theta_t)\n$$\n\nWhere $\\eta$ is the learning rate.\n\n## Partial Derivatives\n\nFor a function $f(x,y)$:\n\n$$\n\\frac{\\partial f}{\\partial x} = \\lim_{h \\to 0} \\frac{f(x+h,y) - f(x,y)}{h}\n$$\n",
    "contentHtml": "<h1>Optimization with Calculus</h1><br/>\n<h2>Gradient Descent</h2>\n<p>\nThe update rule:</p>\n<p>\n$$</p>\n<p>\\theta_{t+1} = \\theta_t - \\eta \\nabla J(\\theta_t)</p>\n<p>$$</p>\n<p>\nWhere $\\eta$ is the learning rate.</p><br/>\n<h2>Partial Derivatives</h2>\n<p>\nFor a function $f(x,y)$:</p>\n<p>\n$$</p>\n<p>\\frac{\\partial f}{\\partial x} = \\lim_{h \\to 0} \\frac{f(x+h,y) - f(x,y)}{h}</p>\n<p>$$</p>"
  },
  {
    "slug": "machine-learning",
    "title": "The Mathematics Behind Neural Networks",
    "date": "2024-01-20T00:00:00.000Z",
    "excerpt": "Exploring the calculus and linear algebra that make deep learning possible.",
    "author": "Danke Hidayat",
    "tags": [
      "Neural Networks",
      "Backpropagation",
      "Calculus"
    ],
    "categories": [
      "Machine Learning",
      "Mathematics"
    ],
    "labels": [
      "Beginner Friendly",
      "Mathematical Foundation"
    ],
    "content": "\n# The Mathematics Behind Neural Networks\n\n## Forward Propagation\n\nA simple neural network layer:\n\n$$\nz = Wx + b\n$$\n\nWhere $W$ is the weight matrix and $b$ is the bias vector.\n\n## Activation Functions\n\nSigmoid function:\n\n$$\n\\sigma(x) = \\frac{1}{1 + e^{-x}}\n$$\n\nReLU function:\n\n$$\n\\text{ReLU}(x) = \\max(0, x)\n$$\n",
    "contentHtml": "<h1>The Mathematics Behind Neural Networks</h1><br/>\n<h2>Forward Propagation</h2>\n<p>\nA simple neural network layer:</p>\n<p>\n$$</p>\n<p>z = Wx + b</p>\n<p>$$</p>\n<p>\nWhere $W$ is the weight matrix and $b$ is the bias vector.</p><br/>\n<h2>Activation Functions</h2>\n<p>\nSigmoid function:</p>\n<p>\n$$</p>\n<p>\\sigma(x) = \\frac{1}{1 + e^{-x}}</p>\n<p>$$</p>\n<p>\nReLU function:</p>\n<p>\n$$</p>\n<p>\\text{ReLU}(x) = \\max(0, x)</p>\n<p>$$</p>"
  },
  {
    "slug": "quatum-computing",
    "title": "Understanding Quantum Computing with Linear Algebra",
    "date": "2024-01-15T00:00:00.000Z",
    "excerpt": "A deep dive into how linear algebra powers quantum computing, exploring qubits, superposition, and quantum gates.",
    "author": "Danke Hidayat",
    "tags": [
      "Linear Algebra",
      "Qubits",
      "Quantum Gates"
    ],
    "categories": [
      "Quantum Computing",
      "Mathematics"
    ],
    "labels": [
      "Technical Deep Dive",
      "Mathematical Foundation"
    ],
    "content": "\n# Understanding Quantum Computing with Linear Algebra\n\nQuantum computing represents one of the most exciting frontiers in modern technology.\n\n## The Mathematics of Qubits\n\n### What is a Qubit?\n\nA qubit exists in a superposition of states:\n\n$$\n|\\psi\\rangle = \\alpha|0\\rangle + \\beta|1\\rangle\n$$\n\nWhere $\\alpha$ and $\\beta$ satisfy:\n\n$$\n|\\alpha|^2 + |\\beta|^2 = 1\n$$\n\n### Quantum Gates\n\nThe Pauli-X gate:\n\n$$\nX = \\begin{pmatrix} 0 & 1 \\\\ 1 & 0 \\end{pmatrix}\n$$\n",
    "contentHtml": "<h1>Understanding Quantum Computing with Linear Algebra</h1>\n<p>\nQuantum computing represents one of the most exciting frontiers in modern technology.</p><br/>\n<h2>The Mathematics of Qubits</h2><br/>\n<h3>What is a Qubit?</h3>\n<p>\nA qubit exists in a superposition of states:</p>\n<p>\n$$</p>\n<p>|\\psi\\rangle = \\alpha|0\\rangle + \\beta|1\\rangle</p>\n<p>$$</p>\n<p>\nWhere $\\alpha$ and $\\beta$ satisfy:</p>\n<p>\n$$</p>\n<p>|\\alpha|^2 + |\\beta|^2 = 1</p>\n<p>$$</p><br/>\n<h3>Quantum Gates</h3>\n<p>\nThe Pauli-X gate:</p>\n<p>\n$$</p>\n<p>X = \\begin{pmatrix} 0 & 1 \\\\ 1 & 0 \\end{pmatrix}</p>\n<p>$$</p>"
  },
  {
    "slug": "test-latex",
    "title": "Testing LaTeX Support",
    "date": "2024-01-01",
    "excerpt": "Testing mathematical notation in MDX",
    "author": "Your Name",
    "tags": [
      "test",
      "math"
    ],
    "categories": [
      "testing"
    ],
    "labels": [
      "demo"
    ],
    "content": "\n# Testing LaTeX in Blog Posts\n\nHere's some **inline math**: $E = mc^2$ and $\\frac{\\pi}{2}$.\n\n## Block Math Examples\n\nThe Gaussian integral:\n\n$$\n\\int_{-\\infty}^{\\infty} e^{-x^2} dx = \\sqrt{\\pi}\n$$\n\nQuadratic formula:\n\n$$\nx = \\frac{-b \\pm \\sqrt{b^2 - 4ac}}{2a}\n$$\n\n## Physics Equations\n\nSchrödinger equation:\n\n$$\ni\\hbar\\frac{\\partial}{\\partial t}\\Psi = \\hat{H}\\Psi\n$$\n\nMaxwell's equations:\n\n$$\n\\begin{aligned}\n\\nabla \\cdot \\mathbf{E} &= \\frac{\\rho}{\\varepsilon_0} \\\\\n\\nabla \\cdot \\mathbf{B} &= 0 \\\\\n\\nabla \\times \\mathbf{E} &= -\\frac{\\partial \\mathbf{B}}{\\partial t} \\\\\n\\nabla \\times \\mathbf{B} &= \\mu_0\\mathbf{J} + \\mu_0\\varepsilon_0\\frac{\\partial \\mathbf{E}}{\\partial t}\n\\end{aligned}\n$$\n\nThis should render beautifully with KaTeX!\n",
    "contentHtml": "<h1>Testing LaTeX in Blog Posts</h1>\n<p>\nHere's some <strong>inline math</strong>: $E = mc^2$ and $\\frac{\\pi}{2}$.</p><br/>\n<h2>Block Math Examples</h2>\n<p>\nThe Gaussian integral:</p>\n<p>\n$$</p>\n<p>\\int_{-\\infty}^{\\infty} e^{-x^2} dx = \\sqrt{\\pi}</p>\n<p>$$</p>\n<p>\nQuadratic formula:</p>\n<p>\n$$</p>\n<p>x = \\frac{-b \\pm \\sqrt{b^2 - 4ac}}{2a}</p>\n<p>$$</p><br/>\n<h2>Physics Equations</h2>\n<p>\nSchrödinger equation:</p>\n<p>\n$$</p>\n<p>i\\hbar\\frac{\\partial}{\\partial t}\\Psi = \\hat{H}\\Psi</p>\n<p>$$</p>\n<p>\nMaxwell's equations:</p>\n<p>\n$$</p>\n<p>\\begin{aligned}</p>\n<p>\\nabla \\cdot \\mathbf{E} &= \\frac{\\rho}{\\varepsilon_0} \\\\</p>\n<p>\\nabla \\cdot \\mathbf{B} &= 0 \\\\</p>\n<p>\\nabla \\times \\mathbf{E} &= -\\frac{\\partial \\mathbf{B}}{\\partial t} \\\\</p>\n<p>\\nabla \\times \\mathbf{B} &= \\mu_0\\mathbf{J} + \\mu_0\\varepsilon_0\\frac{\\partial \\mathbf{E}}{\\partial t}</p>\n<p>\\end{aligned}</p>\n<p>$$</p>\n<p>\nThis should render beautifully with KaTeX!</p>"
  }
]